<!DOCTYPE html>
<html>
<head>
    <title>01.01 - Basic scene</title>
    <script src="libs/three.js"></script>
    <script src="libs/dat.gui.min.js"></script>
    <script src="libs/stats.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/ColladaLoader.js"></script>
    <script src="physi.js"></script>
    <script src="physijs_worker.js"></script>
    <script src="ammo.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<script>

    // global variables
    var renderer;
    var scene;
    var camera;
    var spotLight;
    var cameraControl;
    var ambientLight;
    var object ,cube, line, object2;
    var way = [];
    var way2 = [];
    var pos = 0;
    var obj;
    SPEED=0;
    ROTATION=0;
    vehicles=[];
    var nb = 3;
    var largeurRoute = 20;
    var geom;
    var detailAngle = 10;
 
   /**
     * Initializes the scene, camera and objects. Called when the window is
     * loaded by using window.onload (see below)
     */
    function init() {

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        scene = new Physijs.Scene;
        scene.setGravity(new THREE.Vector3(0,-100,0));

        geom = new THREE.Geometry(); 

        // console.log(geom.vertices.length);
        // drawRect(geom,0,0,80,20);
        // drawRect(geom,100,-20,120,-60);
        // drawRect(geom,80,-80,0,-100);
        // drawRect(geom,-20,-60,-40,-20);

        map_rect(0,0,80,40);

        way2.reverse();

        // way3 = [];
        // for (var i =  0; i < way2.length; i++) {
        //      way3.push({x:way2[i].x+50,y:way2[i].y,z:way2[i].z+50,rot:way2[i].rot,free:true});
        // };
        
        geom.computeFaceNormals();

        var material = Physijs.createMaterial(new THREE.MeshLambertMaterial({color: 0xffffff,side : THREE.DoubleSide}));

        object = new Physijs.BoxMesh( geom, material);

        object.position.z = 0;
        object.rotation.x = Math.PI * -0.5;

        scene.add(object);

        // object2 = object.clone();
        // object2.position.x = 50;
        // object2.position.z = 50;
        // scene.add(object2);

        addLights();

        ground_material = Physijs.createMaterial(
            new THREE.MeshPhongMaterial({opacity:0,transparent:true}),
            .9,
            .6
            );

        ground = new Physijs.BoxMesh(
            new THREE.BoxGeometry(1000,1,1000),
            ground_material
            )

        ground.receiveShadow = true;
        ground.position.y = 0;

        scene.add(ground);

        for (var i = 0 ; i < way.length; i++) {
            var dotGeometry = new THREE.PlaneGeometry(1,1);
            var dotMaterial = new THREE.MeshLambertMaterial({color:0x000000});
            var dot = new THREE.Mesh(dotGeometry,dotMaterial);
            
            dot.rotation.x = -0.5 * Math.PI;
            dot.position.x = way[i].x;
            dot.position.y = way[i].y-6.9;
            dot.position.z = way[i].z;

            // scene.add(dot);
        };

        for (var i = 0 ; i < way2.length; i++) {
            var dotGeometry = new THREE.PlaneGeometry(1,1);
            var dotMaterial = new THREE.MeshLambertMaterial({color:0x000000});
            var dot = new THREE.Mesh(dotGeometry,dotMaterial);
            
            dot.rotation.x = -0.5 * Math.PI;
            dot.position.x = way2[i].x;
            dot.position.y = way2[i].y-6.9;
            dot.position.z = way2[i].z;

            // scene.add(dot);
        };


        // create a cube
        var cubeGeometry = new THREE.BoxGeometry(10,10,10);

        var myTexture = THREE.ImageUtils.loadTexture("assets/textures/wood.png");
        var cubeMaterial = new THREE.MeshPhongMaterial({map:myTexture,transparent : true,opacity:1});

        // var cubeMaterial = new THREE.MeshLambertMaterial({color: 'red',transparent : true,opacity:0.5});
        cube = new Physijs.BoxMesh(cubeGeometry,cubeMaterial,10);
        cube.castShadow = true;
        cube.name = 'cube';
        cube.position.set(20,100,-40);

        // add the cube to the scene
        scene.add(cube);
        // create a cube


        cube.name='dae1';
        // touareg('dae1',0);
        mclaren('dae2',0);


        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        // create a render, sets the background color and the size
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        // position and point the camera to the center of the scene
        camera.position.x = 200;
        camera.position.y = 100;
        camera.position.z = 200;
        camera.lookAt(scene.position);
        cameraControl = new THREE.OrbitControls(camera);

        // setup the control of color, opacity, camera speed...
        control = new function(){
            this.rotationSpeed = 0;
            this.opacity = 0.6;
            this.color = 0xb12929;
        };

        sphereTexture = THREE.ImageUtils.loadTexture("assets/textures/planets/mercurymap.jpg");
        sphereMaterial = new THREE.MeshPhongMaterial({map:sphereTexture,transparent:false,opacity:1});
        SphereGeometry = new THREE.SphereGeometry(1,60,60);
        // addSphere(800);

        // add extra
        addControlGui(control);
        addStatsObject();

        // add the output of the renderer to the html element
        document.body.appendChild(renderer.domElement);

        // call the render function, after the first render, interval is determined
        // by requestAnimationFrame
        render();
        // console.log(object.mate);

    }

    // Cette fonction a pour but de créer un circuit rectangulaire avec les angles arrondis
// Plus précisemment, cela créé l'objet 3D et le tableau de coordonnées du chemin des voitures
function map_rect(x, y, longueurX, longueurY){

    //Création de la forme HAUT
    x1 = x  + largeurRoute*2;
    y1 = y  - largeurRoute;
    x2 = x1 + longueurX
    y2 = y1 + largeurRoute;

    drawRect(x1,y1,x2,y2);

    //Création de la forme HAUT DROITE
    x1 = x  + largeurRoute*2+longueurX;
    y1 = y;
    x2 = x1 + largeurRoute*2;
    y2 = y1 - largeurRoute*2;

    drawCurve(x1,y1,x2,y2,'HD');//RT

    //Création de la forme DROITE
    x1 = x  + largeurRoute*2+longueurX+largeurRoute;
    y1 = y  - largeurRoute*2;
    x2 = x  + largeurRoute*2+longueurX+largeurRoute*2;
    y2 = y  - largeurRoute*2-longueurY;

    drawRect(x1,y1,x2,y2);

    //Création de la forme BAS DROITE
    x1 = x  + largeurRoute*2+longueurX+largeurRoute*2;
    y1 = y  - largeurRoute*2-longueurY;
    x2 = x1 - largeurRoute*2;
    y2 = y1 - largeurRoute*2;

    drawCurve(x1,y1,x2,y2,'BD');//RB

    //Création de la forme BAS
    x1 = x  + largeurRoute*2+longueurX;
    y1 = y  - largeurRoute*2-longueurY-largeurRoute;
    x2 = x1 - longueurX;
    y2 = y1 - largeurRoute;

    drawRect(x1,y1,x2,y2);

    //Création de la forme BAS GAUCHE
    x1 = x + largeurRoute*2;
    y1 = y - largeurRoute*4-longueurY;
    x2 = x;
    y2 = y - largeurRoute*2-longueurY

    drawCurve(x1,y1,x2,y2,'BG');//LB
    
    //Création de la forme GAUCHE
    x1 = x + largeurRoute;
    y1 = y - largeurRoute*2 - longueurY;
    x2 = x;
    y2 = y - largeurRoute*2;

    drawRect(x1,y1,x2,y2);
    
    //Création de la forme HAUT GAUCHE
    x1 = x;
    y1 = y - largeurRoute*2;
    x2 = x + largeurRoute*2;
    y2 = y;

    drawCurve(x1,y1,x2,y2,'HG');//LT
}

    function addCar(vway,aWay){
        var obj = scene.getObjectByName('dae1');
        var obj2 = obj.clone();
        vname='dae'+nb;
        nb++;
        obj2.name=vname;
        obj2.pos=0;
        obj2.position.x = aWay[0].x;
        // obj2.position.y = way2[pos].y-7.1;
        obj2.position.z = aWay[0].z;
        obj2.rotation.y = 0;
        vehicles.push({way:vway,name:vname});
        scene.add(obj2);
    }

    function touareg(name,pos){

        loader = new THREE.ColladaLoader();
        loader.load('assets/models/touareg.dae',function colladaReady( collada ){
            var obj = collada.scene;
            // skin = collada.skins [ 0 ];
            obj.scale.x = obj.scale.y = obj.scale.z = .005;

            //i'll add code here later for extra bump mapping on webgl versions

            //usefull for shadows on webgl version
            // daemesh = player.children[0];
            obj.castShadow = true;
            obj.receiveShadow = true;
            // obj.rotation.y = Math.PI * 1;

            obj.position.x = way2[pos].x;
            obj.position.y = way2[pos].y-7.1;
            obj.position.z = way2[pos].z;
            obj.pos=pos;
            obj.name = name;

            scene.add( obj );
            vehicles.push({way:'way2',name:name});
        });

    }

    function mclaren(name,pos){

        loader = new THREE.ColladaLoader();
        loader.load('assets/models/mclaren/mclaren.dae',function colladaReady( collada ){
            var obj = collada.scene;
            // skin = collada.skins [ 0 ];
            obj.scale.x = obj.scale.y = obj.scale.z = .9;

            //i'll add code here later for extra bump mapping on webgl versions

            //usefull for shadows on webgl version
            // daemesh = player.children[0];
            obj.castShadow = true;
            obj.receiveShadow = true;
            obj.rotation.y = Math.PI * .5;

            obj.position.x = way[pos].x;
            obj.position.y = way[pos].y-7.1;
            obj.position.z = way[pos].z;
            obj.pos=pos;
            obj.name = name;
            scene.add( obj );
            vehicles.push({way:'way',name:name});
        });

    }

        function addSphere(nb){
        for (var i = 0 ; i < nb; i++) {
            var tmpSphere = new Physijs.BoxMesh(SphereGeometry,sphereMaterial);

            var num = Math.floor(Math.random()*100) + 1;
            num *= Math.floor(Math.random()*2) == 1 ? 1 : -1;
            x=num;

            var num = Math.floor(Math.random()*30) + 10;
            // num *= Math.floor(Math.random()*2) == 1 ? 1 : -1;
            y=num;

            var num = Math.floor(Math.random()*100) + 1;
            num *= Math.floor(Math.random()*2) == 1 ? 1 : -1;
            z=num;
            tmpSphere.position.set(x,y,z);
            scene.add(tmpSphere);
        };
    }

    window.onkeydown = checkKey;
    
    function checkKey(e){
        e = e || window.event;

        var factor = 0.3;

        if(e.keyCode == '81'){//left
        }
        if(e.keyCode == '90'){//go
            for (var i = 0; i <= 1; i+=.5) {
                SPEED=i;
            };
            // SPEED=1;
            // go('way2','dae1');
        }
        if(e.keyCode == '68'){//right          
        }
        if(e.keyCode == '83'){//back
            for (var i = 1; i >= 0; i-=.5) {
                SPEED=i;
            };
        }
        if(e.keyCode == '65'){//up
        }
        if(e.keyCode == '69'){//down
        }

        // e.preventDefault();
    }

    function go(wayName,name){
        var obj = scene.getObjectByName(name);

        if(wayName == 'way'){
            for (var i = 0; i < SPEED; i++) {

                if(obj.pos >= way.length){
                    obj.pos = 0;
                }

                obj.position.x = way[obj.pos].x;
                obj.position.y = way[obj.pos].y-7.1;
                obj.position.z = way[obj.pos].z;

                if(way[obj.pos].rot != undefined){
                    obj.rotation.y-=((Math.PI*.5)/39);
                }
                else{
                    if(-obj.rotation.y > 1.5 && -obj.rotation.y < 1.6 ) obj.rotation.y = -Math.PI* .5;
                    if(-obj.rotation.y > 3.1 && -obj.rotation.y < 3.2 ) obj.rotation.y = -Math.PI* 1;
                    if(-obj.rotation.y > 4.7 && -obj.rotation.y < 4.8 ) obj.rotation.y = -Math.PI* 1.5;
                    if(-obj.rotation.y > 6.2 && -obj.rotation.y < 6.3 ) obj.rotation.y = -Math.PI* 2;
                }       
                if(obj.rotation.y <= -Math.PI*2){
                    obj.rotation.y=0;
                }
                obj.pos+=1;
            };
        }
        if(wayName == 'way2'){
            for (var i = 0; i < SPEED; i++) {

                if(obj.pos >= way2.length){
                    obj.pos = 0;
                }

                obj.position.x = way2[obj.pos].x;
                obj.position.y = way2[obj.pos].y-7.1;
                obj.position.z = way2[obj.pos].z;

                if(way2[obj.pos].rot != undefined){
                    obj.rotation.y+=((Math.PI*.5)/39);
                }
                else{
                    if(obj.rotation.y > 1.5 && obj.rotation.y < 1.6 ) obj.rotation.y = Math.PI* .5;
                    if(obj.rotation.y > 3.1 && obj.rotation.y < 3.2 ) obj.rotation.y = Math.PI* 1;
                    if(obj.rotation.y > 4.7 && obj.rotation.y < 4.8 ) obj.rotation.y = Math.PI* 1.5;
                    if(obj.rotation.y > 6.2 && obj.rotation.y < 6.3 ) obj.rotation.y = Math.PI* 2;
                }
                if(obj.rotation.y >= Math.PI*2){
                    obj.rotation.y=0;
                }
                obj.pos+=1;
            };
        }
        if(wayName == 'way3'){
            for (var i = 0; i < SPEED; i++) {

                if(obj.pos >= way3.length){
                    obj.pos = 0;
                }

                obj.position.x = way3[obj.pos].x;
                obj.position.y = way3[obj.pos].y-7.1;
                obj.position.z = way3[obj.pos].z;

                if(way3[obj.pos].rot != undefined){
                    obj.rotation.y+=((Math.PI*.5)/39);
                }
                else{
                    if(obj.rotation.y > 1.5 && obj.rotation.y < 1.6 ) obj.rotation.y = Math.PI* .5;
                    if(obj.rotation.y > 3.1 && obj.rotation.y < 3.2 ) obj.rotation.y = Math.PI* 1;
                    if(obj.rotation.y > 4.7 && obj.rotation.y < 4.8 ) obj.rotation.y = Math.PI* 1.5;
                    if(obj.rotation.y > 6.2 && obj.rotation.y < 6.3 ) obj.rotation.y = Math.PI* 2;
                }
                if(obj.rotation.y >= Math.PI*2){
                    obj.rotation.y=0;
                }
                obj.pos+=1;
            };
        }
        

        // console.log(way[obj.pos].rot);


    }

    function drawRect(x1,y1,x2,y2){

        v1 = new THREE.Vector3(x1,y1,0);
        v2 = new THREE.Vector3(x1,y2,0);
        v3 = new THREE.Vector3(x2,y1,0);
        v4 = new THREE.Vector3(x2,y2,0);
        
        geom.vertices.push(v1);
        geom.vertices.push(v2);
        geom.vertices.push(v3);
        geom.vertices.push(v4);

        i = geom.vertices.length;
        i1 = i-4; 
        i2 = i-3;
        i3 = i-2;
        i4 = i-1;

        geom.faces.push( new THREE.Face3( i1, i2, i3) );
        geom.faces.push( new THREE.Face3( i2, i3, i4) );

        differenceX = x2 - x1;
        differenceY = y2 - y1;


        if( Math.abs(differenceX) > Math.abs(differenceY) ){
            if(differenceX > 0){
                for(i=x1;i<x2;i+=2){
                    way.push({x:i,y:7,z:(largeurRoute*.75),free:true});
                    way2.push({x:i,y:7,z:(largeurRoute*.25),free:true});
                }
            }
            else{        
                for(i=x1;i>x2;i-=2){
                    way.push({x:i,y:7,z:(y2*-1)-largeurRoute*.75,free:true});
                    way2.push({x:i,y:7,z:(y2*-1)-largeurRoute*.25,free:true});
                }

            }
        }
        else{
            if(differenceY > 0){
                for(i=(y1*-1);i>(y2*-1);i-=2){
                    way.push({x:x2+(largeurRoute*.75),y:7,z:i,free:true});
                    way2.push({x:x2+(largeurRoute*.25),y:7,z:i,free:true});
                }

            }
            else{
                for(i=(y1*-1);i<(y2*-1);i+=2){
                    way.push({x:x2-(largeurRoute*.75),y:7,z:i,free:true});
                    way2.push({x:x2-(largeurRoute*.25),y:7,z:i,free:true});
                }
            }
        }
    }

    function drawCurve(x1,y1,x2,y2,corner){

        if(corner == 'HD'){
            xRot = 1;
            yRot = -1;
            xPos = 0;
            yPos = y1+y2;
        }
        if(corner == 'BD'){
            xRot = -1;
            yRot = 1;
            xPos = x1+x2;
            yPos = 0;
        }
        if(corner == 'BG'){
            xRot = 1;
            yRot = -1;
            xPos = 0;//x1;
            yPos = y1+y2;
        }
        if(corner == 'HG'){
            xRot = -1;
            yRot = 1;
            xPos = x1+x2;
            yPos = 0;
        }
        nbVertice = geom.vertices.length;

        for (var i = 0  ; i <= detailAngle ; i++) {
            // console.log(i);
            vTmp = new THREE.Vector3(
                ((x2-x1)/2*(Math.cos(i*Math.PI/(2*detailAngle)))+x1)*xRot+xPos,  // x
                ((y2-y1)/2*(Math.sin(i*Math.PI/(2*detailAngle)))+y1)*yRot+yPos,  // y
                0);                                                         // z
            geom.vertices.push(vTmp);
            vTmp = new THREE.Vector3(
                ((x2-x1)*(Math.cos(i*Math.PI/(2*detailAngle)))+x1)*xRot+xPos,  // x
                ((y2-y1)*(Math.sin(i*Math.PI/(2*detailAngle)))+y1)*yRot+yPos,  // y
                0);                                                         // z
            geom.vertices.push(vTmp);

        };

        tmpArray = [];
        for (var i = 0  ; i <= detailAngle ; i+=.25) {
                x = ((x2-x1)*5/8*(Math.cos(i*Math.PI/(2*detailAngle)))+x1)*xRot+xPos;  // x
                z = -((y2-y1)*5/8*(Math.sin(i*Math.PI/(2*detailAngle)))+y1)*yRot-yPos;  // y
                y = 7;
                rot = Math.cos(Math.PI*i);
                if(i==0 || i == detailAngle){
                    rot = undefined;
                }

                tmpArray.push({x:x,y:7,z:z,rot:rot,free:true});

           }
           if(yRot == -1){
                tmpArray.reverse();         
           }
           way = way.concat(tmpArray);


        tmpArray = [];
        for (var i = 0  ; i <= detailAngle ; i+=.25) {
                x = ((x2-x1)*7/8*(Math.cos(i*Math.PI/(2*detailAngle)))+x1)*xRot+xPos;  // x
                z = -((y2-y1)*7/8*(Math.sin(i*Math.PI/(2*detailAngle)))+y1)*yRot-yPos;  // y
                y = 7;
                rot = Math.cos(Math.PI*i);
                if(i==0 || i == detailAngle){
                    rot = undefined;
                }

                tmpArray.push({x:x,y:7,z:z,rot:rot,free:true});

           }

           if(yRot == -1){
                tmpArray.reverse();         
           }
           way2 = way2.concat(tmpArray);



        for (var i = nbVertice ; i < (detailAngle*2)+nbVertice ; i++) {
            geom.faces.push( new THREE.Face3(i,i+1,i+2));
        };
    }

   


    function addControlGui(controlObject){
        var gui = new dat.GUI();
        gui.add(controlObject, 'rotationSpeed',-0.01,0.01);
        gui.add(controlObject,'opacity', 0.1,1);
        gui.addColor(controlObject, 'color');
    }


    function addStatsObject(){
        stats = new Stats();
        stats.setMode(0);

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        document.body.appendChild(stats.domElement);

    }

    /**
     * Called when the scene needs to be rendered. Delegates to requestAnimationFrame
     * for future renders
     */
    function render() {

        var rotSpeed = control.rotationSpeed;
        // camera.position.x = camera.position.x * Math.cos(rotSpeed) + camera.position.z * Math.sin(rotSpeed);
        // camera.position.z = camera.position.z * Math.cos(rotSpeed) - camera.position.x * Math.sin(rotSpeed);
        // camera.position.y = camera.position.y * Math.cos(rotSpeed) - camera.position.z * Math.sin(rotSpeed);
        camera.lookAt(scene.position);


        // ambientLight.color = new THREE.Color(control.color);

        // FPS update 
        stats.update();
        cameraControl.update();

        // render using requestAnimationFrame
        requestAnimationFrame(render);
        renderer.render(scene, camera);
        // object.material.color = new THREE.Color(parseInt(getRandomColor()));
        scene.simulate();  
        if(SPEED != 0){
            for(i=0;i<vehicles.length;i++){
                go(vehicles[i].way,vehicles[i].name);
            }
        }
    }

function getRandomColor() {
    var letters = '0123456789ABCDEF'.split('');
    var color = '0x';
    for (var i = 0; i < 6; i++ ) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}
    /**
     * Function handles the resize event. This make sure the camera and the renderer
     * are updated at the correct moment.
     */
    function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // calls the init function when the window is done loading.
    window.onload = init;
    // calls the handleResize function when the window is resized
    window.addEventListener('resize', handleResize, false);

    function addLights(){
        // ambientLight = new THREE.AmbientLight(0xffffff);
        // ambientLight.name='ambient';
        // scene.add(ambientLight);

        dirLight = new THREE.DirectionalLight(0xf54123,.4);
        dirLight.position.set(0,500,0);
        dirLight.target.position.set(0,0,0);
        scene.add(dirLight);

        dirLight1 = new THREE.DirectionalLight(0xcccc11,.4);
        dirLight1.position.set(0,-500,0);
        dirLight1.target.position.set(0,0,0);
        scene.add(dirLight1);

        dirLight2 = new THREE.DirectionalLight(0xeeeeef,.5);
        dirLight2.position.set(50,50,0);
        dirLight2.target.position.set(0,50,0);
        scene.add(dirLight2);

        dirLight3 = new THREE.DirectionalLight(0xeeeeef,.5);
        dirLight3.position.set(0,50,50);
        dirLight3.target.position.set(0,50,0);
        scene.add(dirLight3);

        dirLight4 = new THREE.DirectionalLight(0xeeeeef,.5);
        dirLight4.position.set(-50,50,0);
        dirLight4.target.position.set(0,50,0);
        scene.add(dirLight4);

        dirLight45 = new THREE.DirectionalLight(0xeeeeef,.5);
        dirLight45.position.set(0,50,-50);
        dirLight45.target.position.set(0,50,0);
        scene.add(dirLight45);

        // create light
        spotLight = new THREE.SpotLight(0xffffff,0.25);
        spotLight.position.set(0,500,0);
        spotLight.target.position.set(0,0,0);
        scene.add(spotLight);

        // spotLight2 = new THREE.SpotLight(0xff0000,.7);
        // spotLight2.position.set(100,50,0);
        // spotLight2.target.position.set(20,0,0);
        // scene.add(spotLight2);

        // spotLight3 = new THREE.SpotLight(0x00ff00,.7);
        // spotLight3.position.set(0,50,100);
        // spotLight3.target.position.set(0,0,20);
        // scene.add(spotLight3);

        // spotLight4 = new THREE.SpotLight(0x0000ff,.7);
        // spotLight4.position.set(-100,50,-100);
        // spotLight4.target.position.set(-20,0,-20);
        // scene.add(spotLight4);

        // spotLight4 = new THREE.SpotLight(0xffff00,.7);
        // spotLight4.position.set(50,50,50);
        // spotLight4.target.position.set(20,0,20);
        // scene.add(spotLight4);
    }
</script>
<body>
</body>
</html>