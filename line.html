<!DOCTYPE html>
<html>
<head>
    <title>01.01 - Basic scene</title>
    <script src="libs/three.js"></script>
    <script src="libs/dat.gui.min.js"></script>
    <script src="libs/stats.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
        <script src="libs/NURBSCurve.js"></script>
        <script src="libs/NURBSSurface.js"></script>
        <script src="libs/NURBSUtils.js"></script>
    <style>
        body {
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<script>

    // global variables
    var renderer;
    var scene;
    var camera;
    var spotLight;
    var cameraControl;
    var ambientLight;

    /**
     * Initializes the scene, camera and objects. Called when the window is
     * loaded by using window.onload (see below)
     */
    function init() {

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        scene = new THREE.Scene();

        var geom = new THREE.Geometry(); 

        // console.log(geom.vertices.length);
        drawRect(geom,0,0,80,20);
        drawRect(geom,120,-20,100,-60);
        drawRect(geom,0,-80,80,-100);
        drawRect(geom,-40,-20,-20,-60);

        drawCurve2(geom,80,-20,10,'RT');
        drawCurve2(geom,80,-100,10,'RB');
        drawCurve2(geom,-40,-100,10,'LB');
        drawCurve2(geom,-40,-20,10,'LT');
        
        geom.computeFaceNormals();

        var material = new THREE.MeshLambertMaterial({
            color: 0xffffff,
            side : THREE.DoubleSide
        });

        var object = new THREE.Mesh( geom, material );

        object.position.z = 0;//move a bit back - size of 500 is a bit big
        object.rotation.y = -Math.PI * 0;//triangle is pointing in depth, rotate it -90 degrees on Y

        scene.add(object);

        ambientLight = new THREE.AmbientLight(0xffffff);
        ambientLight.name='ambient';
        scene.add(ambientLight);

        // create a camera, which defines where we're looking at.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

        // create a render, sets the background color and the size
        renderer = new THREE.WebGLRenderer();
        renderer.setClearColor(0x000000, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        // position and point the camera to the center of the scene
        camera.position.x = 0;
        camera.position.y = 0;
        camera.position.z = 150;
        camera.lookAt(scene.position);
        cameraControl = new THREE.OrbitControls(camera);

        // setup the control of color, opacity, camera speed...
        control = new function(){
            this.rotationSpeed = 0;
            this.opacity = 0.6;
            this.color = 0xb12929;
        };

        // add extra
        addControlGui(control);
        addStatsObject();

        // add the output of the renderer to the html element
        document.body.appendChild(renderer.domElement);

        // call the render function, after the first render, interval is determined
        // by requestAnimationFrame
        render();
    }

    function drawRect(geom,x1,y1,x2,y2){
        v1 = new THREE.Vector3(x1,y1,0);
        v2 = new THREE.Vector3(x1,y2,0);
        v3 = new THREE.Vector3(x2,y1,0);
        v4 = new THREE.Vector3(x2,y2,0);
        
        geom.vertices.push(v1);
        geom.vertices.push(v2);
        geom.vertices.push(v3);
        geom.vertices.push(v4);

        i = geom.vertices.length;
        i1 = i-4; 
        i2 = i-3;
        i3 = i-2;
        i4 = i-1;

        geom.faces.push( new THREE.Face3( i1, i2, i3) );
        geom.faces.push( new THREE.Face3( i2, i3, i4) );
    }

    function drawCurve2(geom,x1,y1,detail,corner){
        x2=x1+40;
        y2=y1+40;
        if(corner == 'RT'){
            xRot = 1;
            yRot = 1;
            xPos = 0;
            yPos = 0;
        }
        if(corner == 'LT'){
            xRot = -1;
            yRot = 1;
            xPos = x1+x2;
            yPos = 0;
        }
        if(corner == 'RB'){
            xRot = 1;
            yRot = -1;
            xPos = 0;
            yPos = y1+y2;
        }
        if(corner == 'LB'){
            xRot = -1;
            yRot = -1;
            xPos = x1+x2;
            yPos = y1+y2;
        }
        nbVertice = geom.vertices.length;

        for (var i = detail  ; i >= 0 ; i--) {
            vTmp = new THREE.Vector3(
                ((x2-x1)/2*(Math.cos(i*Math.PI/(2*detail)))+x1)*xRot+xPos,  // x
                ((y2-y1)/2*(Math.sin(i*Math.PI/(2*detail)))+y1)*yRot+yPos,  // y
                0);                                                         // z
            geom.vertices.push(vTmp);
            vTmp = new THREE.Vector3(
                ((x2-x1)*(Math.cos(i*Math.PI/(2*detail)))+x1)*xRot+xPos,  // x
                ((y2-y1)*(Math.sin(i*Math.PI/(2*detail)))+y1)*yRot+yPos,  // y
                0);                                                         // z
            geom.vertices.push(vTmp);
        };

        for (var i = nbVertice ; i < (detail*2)+nbVertice ; i++) {
            geom.faces.push( new THREE.Face3(i,i+1,i+2));
        };
    }

    function drawCurve(geom,x1,y1,x2,y2,detail,corner){
        if(corner == 'RT'){
            xRot = 1;
            yRot = 1;
            xPos = 0;
            yPos = 0;
        }
        if(corner == 'LT'){
            xRot = -1;
            yRot = 1;
            xPos = x1+x2;
            yPos = 0;
        }
        if(corner == 'RB'){
            xRot = 1;
            yRot = -1;
            xPos = 0;
            yPos = y1+y2;
        }
        if(corner == 'LB'){
            xRot = -1;
            yRot = -1;
            xPos = x1+x2;
            yPos = y1+y2;
        }
        nbVertice = geom.vertices.length;

        v1 = new THREE.Vector3(x1*xRot+xPos,y1*yRot+yPos,0);
        v2 = new THREE.Vector3(x1*xRot+xPos,y2*yRot+yPos,0);

        geom.vertices.push(v1);
        geom.vertices.push(v2);

        for (var i = detail - 1 ; i > 0 ; i--) {
            vTmp = new THREE.Vector3(
                ((x2-x1)*(Math.cos(i*Math.PI/(2*detail)))+x1)*xRot+xPos,  // x
                ((y2-y1)*(Math.sin(i*Math.PI/(2*detail)))+y1)*yRot+yPos,  // y
                0);                                             // z
            geom.vertices.push(vTmp);
        };

        v5 = new THREE.Vector3(x2*xRot+xPos,y1*yRot+yPos,0);
        geom.vertices.push(v5);

        for (var i = 1 ; i < detail + 1 ; i++) {
            geom.faces.push( new THREE.Face3(nbVertice,nbVertice+i,nbVertice+i+1));
        };
    }


    function addControlGui(controlObject){
        var gui = new dat.GUI();
        gui.add(controlObject, 'rotationSpeed',-0.01,0.01);
        gui.add(controlObject,'opacity', 0.1,1);
        gui.addColor(controlObject, 'color');
    }


    function addStatsObject(){
        stats = new Stats();
        stats.setMode(0);

        stats.domElement.style.position = 'absolute';
        stats.domElement.style.left = '0px';
        stats.domElement.style.top = '0px';

        document.body.appendChild(stats.domElement);

    }

    /**
     * Called when the scene needs to be rendered. Delegates to requestAnimationFrame
     * for future renders
     */
    function render() {
        var rotSpeed = control.rotationSpeed;
        // camera.position.x = camera.position.x * Math.cos(rotSpeed) + camera.position.z * Math.sin(rotSpeed);
        // camera.position.z = camera.position.z * Math.cos(rotSpeed) - camera.position.x * Math.sin(rotSpeed);
        // camera.position.y = camera.position.y * Math.cos(rotSpeed) - camera.position.z * Math.sin(rotSpeed);
        camera.lookAt(scene.position);


        ambientLight.color = new THREE.Color(control.color);

        // FPS update 
        stats.update();
        cameraControl.update();

        // render using requestAnimationFrame
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }


    /**
     * Function handles the resize event. This make sure the camera and the renderer
     * are updated at the correct moment.
     */
    function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // calls the init function when the window is done loading.
    window.onload = init;
    // calls the handleResize function when the window is resized
    window.addEventListener('resize', handleResize, false);

</script>
<body>
</body>
</html>